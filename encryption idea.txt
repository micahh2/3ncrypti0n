Encryption software idea:

ENCRYPTION:
First: create a function that generates non-identical characters and/or strings for a single character.
		The idea is to create several non-identical strings of all different sizes for encrypting each
		character code from an ascii table (probably just the positive values) that I created or that is
		the standard. Also, strings of the same size can be associated with a single character. This will
		generate a key in which each character is associated with several strings. This is to prevent the
		possibility of seeing a pattern when the same character is typed, meaning that you may end up
		recieving the same character for a different string that is not associated with any other
		character.

Second: Take the key and a string of characters and systematically replace each character of the string
		with one of the associated strings for that character.
		The string length of the string generated by the key your replacing the character with is
		generated by a sequence formula that gives the same result each time run it.
		Ex:
			string from file - cat
			first term from formula - 4
			strings of length 4 associated with c --> a5}. 
								  4h,d 
								  ?772 ect...
			second term - 3
			strings of length 3 associated with a --> 2wq
								  6.h
								  ?~3 ect...
			second term from formula - 7
			strings of length 7 associated with t --> ;3\]4fg
								   n&!2oaw
								   3v./;ds
			string that could represent "cat" --> ?7722wq3v./;ds
								   
//NOTE: May not use the whole formula idea, thinking about having the numbers be randomly generated and saved
//to a different file or the end of the key.
//Either way I plan to have the numbers placed at the end of my key after the EOF marking if possible. So if someone got a hold of that keys
//its "hopefully" not likely that he will notice the characters after the EOF marking (not that it would make that large of a difference).
//Another possible option is to save the numbers to the encrypted file after the eof marking.
//eof marking could be one of many depending on the operating system. -1 through -8, \0, cntr z, 0xff
//Most commonly the value of EOF is -1 because it has to be different from any return value from getchar that is an actual character. 
//So getchar returns any character value as an unsigned char, converted to int, which will therefore be non-negative.
		
		My plan is to associate each character with 24 (or more) strings per string size at a max length of 
		9 and a min of 2 (or more) characters (from unicode) (so (9-1) * 24 strings per char) instead of using
		the max number possible of strings per length of that string (ex: (128*128)/128 characters for 2
		character string). This is to shorten the amount of values i get in my key for easier searching
		when doing decryption and so i dont go overboard when allocating memory to creating the key.
		//course allocating memory probably wouldn't be a problem if i saved everthing to a file before i generated another string.

Third:	A second key using the same or similar method from step one might also be created to further
		negate the possibility of seeing a pattern within the encrypted file where the string length
		would be determined by a different sequence formula. The max string length and strings
		associated with a character may change.
//NOTE: May do a ascii encryption on the first encryption then do a unicode encryption on the second. This
		would make the second ecryption a hell of a lot easier to deal with.

DECRYPTION:
Forth:	To decrypt the encrypted file you would first use your second key and the provided formula for
		that key to replace the string with the index of the last character being the the sum of the
		sequence and the first last term of your series s_(n-1) + 1 and replace that string by searching
		your key for the an identical matching string with the associated character
		Ex:
			content in file - jdfq4u590ugfkjaq905
			
			first term from formula - 4
			second term from formula - 2
			
			first set to look at - jdfq
			replace with character 'x'
			first term of series = 4
			
			second set to look at - 4u
			replace with character 'y'
			second term of series = 4 + 2 = 6 // index [4] being the first char and index [6-1] being the last

Fifth:	To decrypt that file, use the same steps from 4 with the first formula and first key (assuming a second encryption is done).

Links to look at:http://support.microsoft.com/kb/108385
				 http://www.codeproject.com/Articles/4563/Upgrading-an-STL-based-application-to-use-Unicode